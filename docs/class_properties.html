<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>fieldedge_utilities.class_properties API documentation</title>
<meta name="description" content="FieldEdge class/property helpers" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fieldedge_utilities.class_properties</code></h1>
</header>
<section id="section-intro">
<p>FieldEdge class/property helpers</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;FieldEdge class/property helpers
&#34;&#34;&#34;

import json
import logging
import os
import re
import itertools
from time import time

from .logger import verbose_logging
from .path import get_caller_name

PROPERTY_CACHE_DEFAULT = int(os.getenv(&#39;PROPERTY_CACHE_DEFAULT&#39;, 5))

_log = logging.getLogger(__name__)


def snake_to_camel(snake_str: str, skip_caps: bool = False) -&gt; str:
    &#34;&#34;&#34;Converts a snake_case string to camelCase.
    
    Args:
        snake_str: The string to convert.
        skip_caps: If `True` will return CAPITAL_CASE unchanged
    
    Returns:
        The input string in camelCase structure.
        
    &#34;&#34;&#34;
    if not isinstance(snake_str, str) or not snake_str:
        raise ValueError(&#39;Invalid string input&#39;)
    if snake_str.isupper() and skip_caps:
        return snake_str
    words = snake_str.split(&#39;_&#39;)
    if len(words) == 1 and words[0] == snake_str:
        return snake_str
    return words[0].lower() + &#39;&#39;.join(w.title() for w in words[1:])


def camel_to_snake(camel_str: str, skip_caps: bool = False) -&gt; str:
    &#34;&#34;&#34;Converts a camelCase string to snake_case.
    
    Args:
        camel_str: The string to convert.
        skip_caps: A flag if `True` will return CAPITAL_CASE unchanged.
        
    Returns:
        The input string in snake_case format.
        
    Raises:
        `ValueError` if camel_str is not a valid string.
        
    &#34;&#34;&#34;
    if not isinstance(camel_str, str) or not camel_str:
        raise ValueError(&#39;Invalid string input&#39;)
    if camel_str.isupper() and skip_caps:
        return camel_str
    snake_str = re.compile(r&#39;(?&lt;!^)(?=[A-Z])&#39;).sub(&#39;_&#39;, camel_str).lower()
    if &#39;__&#39; in snake_str:
        words = snake_str.split(&#39;__&#39;)
        snake_str = &#39;_&#39;.join(f&#39;{word.replace(&#34;_&#34;, &#34;&#34;)}&#39; for word in words)
    return snake_str


def cache_valid(ref_time: &#39;int|float&#39;,
                max_age: int = PROPERTY_CACHE_DEFAULT,
                tag: str = None,
                ) -&gt; bool:
    &#34;&#34;&#34;Determines if cached property value is younger than the threshold.
    
    `PROPERTY_CACHE_DEFAULT` = 5 seconds. Can be overridden as an environment
    variable.
    Many FieldEdge Class properties are derived from *slow* operations but may
    be queried in rapid succession and can be inter-dependent. Caching reduces
    query time for such values.
    
    Args:
        ref: The reference time (seconds) of the previously cached value
            (typically a private property held in a dictionary)
        max_age: The maximum age of the cached value in seconds.
        tag: The name of the property (used for debug purposes).
    
    Returns:
        False is the cache is stale and a new value should be queried from the
            raw resource.

    &#34;&#34;&#34;
    if not isinstance(ref_time, int):
        try:
            ref_time = int(ref_time)
        except:
            raise ValueError(&#39;Invalid reference time&#39;)
    cache_age = int(time()) - ref_time
    if cache_age &gt; max_age:
        if _vlog():
            tag = tag or &#39;?&#39;
            _log.debug(f&#39;Cached {tag} only {cache_age} seconds old&#39;
                       f&#39; (cache = {max_age}s)&#39;)
        return False
    if tag:
        _log.debug(f&#39;Using cached {tag} ({cache_age} seconds)&#39;)
    return True


def get_class_properties(cls_instance: object,
                         ignore: &#39;list[str]&#39; = [],
                         categorize: bool = False,
                         ) -&gt; &#39;dict|dict[str, dict]&#39;:
    &#34;&#34;&#34;Returns non-hidden, non-callable properties/values of a Class instance.
    
    Args:
        cls_instance: The Class instance whose properties/values will be derived
        ignore: A list of names to ignore (optional)
        categorize: If `True` the properties will be grouped as `read_only` or
            `read_write`.
    
    Returns:
        A dictionary as `{ &#39;property&#39;: &lt;value&gt; }`. If `categorize`
            flag is set the return dictionary structure is:
            `{ &#39;read_write&#39;: { &#39;property&#39;: &lt;value&gt; },
            &#39;read_only&#39;: { &#39;property&#39;: &lt;value&gt; } }`
        
    Raises:
        ValueError if cls_instance does not have a `dir` method.
        
    &#34;&#34;&#34;
    if not dir(cls_instance):
        raise ValueError(&#39;Invalid cls_instance - must have dir() method&#39;)
    props = {}
    props_list = [a for a in dir(cls_instance)
                  if not a.startswith((&#39;_&#39;, &#39;properties&#39;)) and
                  a not in ignore and
                  not callable(getattr(cls_instance, a))]
    for prop in props_list:
        props[prop] = getattr(cls_instance, prop)
    if not categorize:
        return props
    ro_props = [attr for attr, val in vars(cls_instance.__class__).items()
                if isinstance(val, property) and val.fset is None and
                attr not in ignore]
    read_only = {}
    read_write = {}
    for prop in props:
        if prop in ro_props:
            read_only[prop] = props[prop]
        else:
            read_write[prop] = props[prop]
    categorized = {}
    if read_only:
        categorized[&#39;read_only&#39;] = read_only
    if read_write:
        categorized[&#39;read_write&#39;] = read_write
    return categorized


def tag_class_properties(instance: object,
                         tag: str = None,
                         json: bool = True,
                         categorize: bool = False,
                         include_values: bool = False,
                         ignore: &#39;list[str]&#39; = [],
                         ) -&gt; &#39;list|dict&#39;:
    &#34;&#34;&#34;Retrieves the class public properties tagged with a routing prefix.
    
    If a `tag` is not provided, the lowercase name of the instance&#39;s class will
    be used.
    
    Using the defaults will return a simple list of tagged property names
    with the form `[&#39;tagProp1Name&#39;, &#39;tagProp2Name&#39;]`
    
    If `categorize` is `True` a dictionary is returned of the form
    `{ &#39;read_only&#39;: [&#39;tagProp1Name&#39;], &#39;read_write&#39;: [&#39;tagProp2Name&#39;]}` where
    `read_only` or `read_write` are not present if no properties meet the
    respective criteria. If `include_values` is also `True` each list will be
    replaced by a nested dictionary
    `{ &#39;tagProp1Name&#39;: &lt;prop1_value&gt;, &#39;tagProp2Name&#39;: &lt;prop2_value&gt; }`
    
    If `categorize` is `False` and `include_values` is `True` then a simple
    dictionary of tagged names and values will be returned with the form
    `{ &#39;tagProp1Name&#39;: &lt;prop1_value&gt;, &#39;tagProp2Name&#39;: &lt;prop2_value&gt; }`
    
    If `json` is `False` the above applies but property names will use
    their original case e.g. `tag_prop1_name`
    
    Args:
        instance: A class instance to tag.
        tag: The name of the routing prefix. If `None`, the calling function&#39;s
            module `__name__` will be used.
        json: A flag indicating whether to use camelCase keys.
        categorize: A flag indicating whether to group as `read_only` and
            `read_write`.
        include_values: A flag indicating whether to return values or just
            a list of property names.
        ignore: A list of property names to ignore.
    
    Retuns:
        A dictionary or list of strings (see docstring).
        
    &#34;&#34;&#34;
    if not isinstance(tag, str) or not tag:
        tag = get_tag_class(instance)
    class_props = get_class_properties(instance, ignore, categorize)
    if not categorize:
        if not include_values:
            return [tag_property(tag, prop, json) for prop in class_props]
        result = {}
        for prop, val in class_props.items():
            result[tag_property(tag, prop, json)] = val
        return result
    result = {}
    for category, props in class_props.items():
        assert isinstance(props, dict)
        if not include_values:
            result[category] = [tag_property(tag, prop, json) for prop in props]
        else:
            result[category] = {}
            for prop, val in props.items():
                result[category][tag_property(tag, prop, json)] = val
    return result


def tag_property(tag: str, prop: str, json: bool = True):
    if json:
        return snake_to_camel(f&#39;{tag}_{prop}&#39;)
    return f&#39;{tag}_{prop}&#39;


def get_tag_class(instance: object) -&gt; str:
    return instance.__class__.__name__.lower()


def untag_class_property(tagged_property: str,
                         tag_or_instance: &#39;str|object&#39; = None,
                         include_tag: bool = False,
                         ) -&gt; &#39;str|tuple[str, str]&#39;:
    &#34;&#34;&#34;Reverts a JSON-format tagged property to its PEP representation.
    
    Expects a JSON-format tagged value e.g. `modemUniqueId` would return
    `(unique_id, modem)`.

    Args:
        tagged_property: The tagged property value, allowing for camelCase.
        tag: Optional to specify the tag, allowing for camelCase tags.
        include_tag: If True, a tuple is returned with the tag as the second
            element.
    
    Returns:
        A string with the original property name, or a tuple with the original
            property value in snake_case, and the tag

    &#34;&#34;&#34;
    if not isinstance(tag_or_instance, str):
        if not isinstance(tag_or_instance, object):
            raise ValueError(&#39;Missing tag or class instance to derive tag&#39;)
        tag = get_tag_class(tag_or_instance)
    else:
        tag = tag_or_instance
    if not tagged_property.startswith(tag):
        raise ValueError(f&#39;{tagged_property} does not start with {tag}&#39;)
    prop = camel_to_snake(tagged_property.replace(tag_or_instance, &#39;&#39;, 1))
    if not include_tag:
        return prop
    return (prop, tag)


def tag_merge(*args) -&gt; &#39;list|dict&#39;:
    &#34;&#34;&#34;Merge multiple tagged property lists/dictionaries.
    
    Args:
        *args: A set of dictionaries or lists, must all be the same structure.
    
    Returns:
        Merged structure of whatever was passed in.

    &#34;&#34;&#34;
    container_type = args[0].__class__.__name__
    if container_type not in (&#39;list&#39;, &#39;dict&#39;):
        raise ValueError(&#39;tag merge must be of list or dict type&#39;)
    if not all(arg.__class__.__name__ == container_type for arg in args):
        raise ValueError(&#39;args must all be of same type&#39;)
    if container_type == &#39;list&#39;:
        return list(itertools.chain(*args))
    merged = {}
    categories = [&#39;read_only&#39;, &#39;read_write&#39;]
    dict_0: dict = args[0]
    if any(k in categories for k in dict_0):
        for arg in args:
            assert isinstance(arg, dict)
            if not any(k in categories for k in arg):
                raise ValueError(&#39;Not all dictionaries are categorized&#39;)
            merged = _nested_tag_merge(arg, merged)
    else:
        for arg in args:
            assert isinstance(arg, dict)
            for k, v in arg.items():
                merged[k] = v      
    return merged


def _nested_tag_merge(add: dict, merged: dict) -&gt; dict:
    for k, v in add.items():
        if k not in merged:
            merged[k] = v
        else:
            if isinstance(merged[k], list):
                merged[k] = merged[k] + v
            else:
                assert isinstance(merged[k], dict)
                assert isinstance(v, dict)
                for nk, nv in v.items():
                    merged[k][nk] = nv
    return merged


def json_compatible(obj: object,
                    camel_keys: bool = True,
                    skip_caps: bool = True) -&gt; dict:
    &#34;&#34;&#34;Returns a dictionary compatible with `json.dumps` function.

    Nested objects are converted to dictionaries.
    
    Args:
        obj: The source object.
        camel_keys: Flag indicating whether to convert all nested dictionary
            keys to `camelCase`.
        skip_caps: Preserves `CAPITAL_CASE` keys if True
        
    Returns:
        A dictionary with nested arrays, dictionaries and other compatible with
            `json.dumps`.

    &#34;&#34;&#34;
    res = obj
    if camel_keys:
        if isinstance(obj, dict):
            res = {}
            for k, v in obj.items():
                if ((isinstance(k, str) and k.isupper() and skip_caps) or
                    not isinstance(k, str)):
                    # no change
                    camel_key = k
                else:
                    camel_key = snake_to_camel(str(k))
                if camel_key != k:
                    _log.debug(f&#39;Changed {k} to {camel_key}&#39;)
                res[camel_key] = json_compatible(v, camel_keys, skip_caps)
        elif isinstance(obj, list):
            res = []
            for item in obj:
                res.append(json_compatible(item, camel_keys, skip_caps))
    try:
        json.dumps(res)
    except TypeError:
        try:
            if isinstance(res, list):
                _temp = []
                for element in res:
                    _temp.append(json_compatible(element,
                                                 camel_keys,
                                                 skip_caps))
                res = _temp
            if hasattr(res, &#39;__dict__&#39;):
                simplified = get_class_properties(res)
                res = json_compatible(simplified)
            if isinstance(res, dict):
                res = json_compatible(res, camel_keys, skip_caps)
        except Exception as err:
            _log.error(err)
    finally:
        return res


def equivalent_attributes(reference: object,
                          other: object,
                          exclude: &#39;list[str]&#39; = None,
                          ) -&gt; bool:
    &#34;&#34;&#34;Confirms attribute equivalence between objects of the same type.
    
    Args:
        reference: The reference object being compared to.
        other: The object comparing against the reference.
        exclude: Optional list of attribute names to exclude from comparison.
    
    Returns:
        True if all (non-excluded) attribute name/values match.

    &#34;&#34;&#34;
    if type(reference) != type(other):
        return False
    if not hasattr(reference, &#39;__dict__&#39;) or not hasattr(other, &#39;__dict__&#39;):
        return reference == other
    for attr, val in vars(reference).items():
        if exclude is not None and attr in exclude:
            continue
        if not hasattr(other, attr):
            _log.warning(f&#39;Other missing {attr}&#39;)
            return False
        if val != vars(other)[attr]:
            _log.warning(f&#39;{val} != {vars(other)[attr]}&#39;)
            return False
    return True


def _vlog() -&gt; bool:
    return verbose_logging(&#39;classes&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fieldedge_utilities.class_properties.cache_valid"><code class="name flex">
<span>def <span class="ident">cache_valid</span></span>(<span>ref_time: int|float, max_age: int = 5, tag: str = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if cached property value is younger than the threshold.</p>
<p><code>PROPERTY_CACHE_DEFAULT</code> = 5 seconds. Can be overridden as an environment
variable.
Many FieldEdge Class properties are derived from <em>slow</em> operations but may
be queried in rapid succession and can be inter-dependent. Caching reduces
query time for such values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ref</code></strong></dt>
<dd>The reference time (seconds) of the previously cached value
(typically a private property held in a dictionary)</dd>
<dt><strong><code>max_age</code></strong></dt>
<dd>The maximum age of the cached value in seconds.</dd>
<dt><strong><code>tag</code></strong></dt>
<dd>The name of the property (used for debug purposes).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>False is the cache is stale and a new value should be queried from the
raw resource.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cache_valid(ref_time: &#39;int|float&#39;,
                max_age: int = PROPERTY_CACHE_DEFAULT,
                tag: str = None,
                ) -&gt; bool:
    &#34;&#34;&#34;Determines if cached property value is younger than the threshold.
    
    `PROPERTY_CACHE_DEFAULT` = 5 seconds. Can be overridden as an environment
    variable.
    Many FieldEdge Class properties are derived from *slow* operations but may
    be queried in rapid succession and can be inter-dependent. Caching reduces
    query time for such values.
    
    Args:
        ref: The reference time (seconds) of the previously cached value
            (typically a private property held in a dictionary)
        max_age: The maximum age of the cached value in seconds.
        tag: The name of the property (used for debug purposes).
    
    Returns:
        False is the cache is stale and a new value should be queried from the
            raw resource.

    &#34;&#34;&#34;
    if not isinstance(ref_time, int):
        try:
            ref_time = int(ref_time)
        except:
            raise ValueError(&#39;Invalid reference time&#39;)
    cache_age = int(time()) - ref_time
    if cache_age &gt; max_age:
        if _vlog():
            tag = tag or &#39;?&#39;
            _log.debug(f&#39;Cached {tag} only {cache_age} seconds old&#39;
                       f&#39; (cache = {max_age}s)&#39;)
        return False
    if tag:
        _log.debug(f&#39;Using cached {tag} ({cache_age} seconds)&#39;)
    return True</code></pre>
</details>
</dd>
<dt id="fieldedge_utilities.class_properties.camel_to_snake"><code class="name flex">
<span>def <span class="ident">camel_to_snake</span></span>(<span>camel_str: str, skip_caps: bool = False) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a camelCase string to snake_case.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>camel_str</code></strong></dt>
<dd>The string to convert.</dd>
<dt><strong><code>skip_caps</code></strong></dt>
<dd>A flag if <code>True</code> will return CAPITAL_CASE unchanged.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The input string in snake_case format.</p>
<h2 id="raises">Raises</h2>
<p><code>ValueError</code> if camel_str is not a valid string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def camel_to_snake(camel_str: str, skip_caps: bool = False) -&gt; str:
    &#34;&#34;&#34;Converts a camelCase string to snake_case.
    
    Args:
        camel_str: The string to convert.
        skip_caps: A flag if `True` will return CAPITAL_CASE unchanged.
        
    Returns:
        The input string in snake_case format.
        
    Raises:
        `ValueError` if camel_str is not a valid string.
        
    &#34;&#34;&#34;
    if not isinstance(camel_str, str) or not camel_str:
        raise ValueError(&#39;Invalid string input&#39;)
    if camel_str.isupper() and skip_caps:
        return camel_str
    snake_str = re.compile(r&#39;(?&lt;!^)(?=[A-Z])&#39;).sub(&#39;_&#39;, camel_str).lower()
    if &#39;__&#39; in snake_str:
        words = snake_str.split(&#39;__&#39;)
        snake_str = &#39;_&#39;.join(f&#39;{word.replace(&#34;_&#34;, &#34;&#34;)}&#39; for word in words)
    return snake_str</code></pre>
</details>
</dd>
<dt id="fieldedge_utilities.class_properties.equivalent_attributes"><code class="name flex">
<span>def <span class="ident">equivalent_attributes</span></span>(<span>reference: object, other: object, exclude: list[str] = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Confirms attribute equivalence between objects of the same type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>reference</code></strong></dt>
<dd>The reference object being compared to.</dd>
<dt><strong><code>other</code></strong></dt>
<dd>The object comparing against the reference.</dd>
<dt><strong><code>exclude</code></strong></dt>
<dd>Optional list of attribute names to exclude from comparison.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if all (non-excluded) attribute name/values match.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equivalent_attributes(reference: object,
                          other: object,
                          exclude: &#39;list[str]&#39; = None,
                          ) -&gt; bool:
    &#34;&#34;&#34;Confirms attribute equivalence between objects of the same type.
    
    Args:
        reference: The reference object being compared to.
        other: The object comparing against the reference.
        exclude: Optional list of attribute names to exclude from comparison.
    
    Returns:
        True if all (non-excluded) attribute name/values match.

    &#34;&#34;&#34;
    if type(reference) != type(other):
        return False
    if not hasattr(reference, &#39;__dict__&#39;) or not hasattr(other, &#39;__dict__&#39;):
        return reference == other
    for attr, val in vars(reference).items():
        if exclude is not None and attr in exclude:
            continue
        if not hasattr(other, attr):
            _log.warning(f&#39;Other missing {attr}&#39;)
            return False
        if val != vars(other)[attr]:
            _log.warning(f&#39;{val} != {vars(other)[attr]}&#39;)
            return False
    return True</code></pre>
</details>
</dd>
<dt id="fieldedge_utilities.class_properties.get_class_properties"><code class="name flex">
<span>def <span class="ident">get_class_properties</span></span>(<span>cls_instance: object, ignore: list[str] = [], categorize: bool = False) ‑> dict | dict[str, dict]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns non-hidden, non-callable properties/values of a Class instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cls_instance</code></strong></dt>
<dd>The Class instance whose properties/values will be derived</dd>
<dt><strong><code>ignore</code></strong></dt>
<dd>A list of names to ignore (optional)</dd>
<dt><strong><code>categorize</code></strong></dt>
<dd>If <code>True</code> the properties will be grouped as <code>read_only</code> or
<code>read_write</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary as <code>{ 'property': &lt;value&gt; }</code>. If <code>categorize</code>
flag is set the return dictionary structure is:
<code>{ 'read_write': { 'property': &lt;value&gt; },
'read_only': { 'property': &lt;value&gt; } }</code></p>
<h2 id="raises">Raises</h2>
<p>ValueError if cls_instance does not have a <code>dir</code> method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_class_properties(cls_instance: object,
                         ignore: &#39;list[str]&#39; = [],
                         categorize: bool = False,
                         ) -&gt; &#39;dict|dict[str, dict]&#39;:
    &#34;&#34;&#34;Returns non-hidden, non-callable properties/values of a Class instance.
    
    Args:
        cls_instance: The Class instance whose properties/values will be derived
        ignore: A list of names to ignore (optional)
        categorize: If `True` the properties will be grouped as `read_only` or
            `read_write`.
    
    Returns:
        A dictionary as `{ &#39;property&#39;: &lt;value&gt; }`. If `categorize`
            flag is set the return dictionary structure is:
            `{ &#39;read_write&#39;: { &#39;property&#39;: &lt;value&gt; },
            &#39;read_only&#39;: { &#39;property&#39;: &lt;value&gt; } }`
        
    Raises:
        ValueError if cls_instance does not have a `dir` method.
        
    &#34;&#34;&#34;
    if not dir(cls_instance):
        raise ValueError(&#39;Invalid cls_instance - must have dir() method&#39;)
    props = {}
    props_list = [a for a in dir(cls_instance)
                  if not a.startswith((&#39;_&#39;, &#39;properties&#39;)) and
                  a not in ignore and
                  not callable(getattr(cls_instance, a))]
    for prop in props_list:
        props[prop] = getattr(cls_instance, prop)
    if not categorize:
        return props
    ro_props = [attr for attr, val in vars(cls_instance.__class__).items()
                if isinstance(val, property) and val.fset is None and
                attr not in ignore]
    read_only = {}
    read_write = {}
    for prop in props:
        if prop in ro_props:
            read_only[prop] = props[prop]
        else:
            read_write[prop] = props[prop]
    categorized = {}
    if read_only:
        categorized[&#39;read_only&#39;] = read_only
    if read_write:
        categorized[&#39;read_write&#39;] = read_write
    return categorized</code></pre>
</details>
</dd>
<dt id="fieldedge_utilities.class_properties.get_tag_class"><code class="name flex">
<span>def <span class="ident">get_tag_class</span></span>(<span>instance: object) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tag_class(instance: object) -&gt; str:
    return instance.__class__.__name__.lower()</code></pre>
</details>
</dd>
<dt id="fieldedge_utilities.class_properties.json_compatible"><code class="name flex">
<span>def <span class="ident">json_compatible</span></span>(<span>obj: object, camel_keys: bool = True, skip_caps: bool = True) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary compatible with <code>json.dumps</code> function.</p>
<p>Nested objects are converted to dictionaries.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong></dt>
<dd>The source object.</dd>
<dt><strong><code>camel_keys</code></strong></dt>
<dd>Flag indicating whether to convert all nested dictionary
keys to <code>camelCase</code>.</dd>
<dt><strong><code>skip_caps</code></strong></dt>
<dd>Preserves <code>CAPITAL_CASE</code> keys if True</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary with nested arrays, dictionaries and other compatible with
<code>json.dumps</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json_compatible(obj: object,
                    camel_keys: bool = True,
                    skip_caps: bool = True) -&gt; dict:
    &#34;&#34;&#34;Returns a dictionary compatible with `json.dumps` function.

    Nested objects are converted to dictionaries.
    
    Args:
        obj: The source object.
        camel_keys: Flag indicating whether to convert all nested dictionary
            keys to `camelCase`.
        skip_caps: Preserves `CAPITAL_CASE` keys if True
        
    Returns:
        A dictionary with nested arrays, dictionaries and other compatible with
            `json.dumps`.

    &#34;&#34;&#34;
    res = obj
    if camel_keys:
        if isinstance(obj, dict):
            res = {}
            for k, v in obj.items():
                if ((isinstance(k, str) and k.isupper() and skip_caps) or
                    not isinstance(k, str)):
                    # no change
                    camel_key = k
                else:
                    camel_key = snake_to_camel(str(k))
                if camel_key != k:
                    _log.debug(f&#39;Changed {k} to {camel_key}&#39;)
                res[camel_key] = json_compatible(v, camel_keys, skip_caps)
        elif isinstance(obj, list):
            res = []
            for item in obj:
                res.append(json_compatible(item, camel_keys, skip_caps))
    try:
        json.dumps(res)
    except TypeError:
        try:
            if isinstance(res, list):
                _temp = []
                for element in res:
                    _temp.append(json_compatible(element,
                                                 camel_keys,
                                                 skip_caps))
                res = _temp
            if hasattr(res, &#39;__dict__&#39;):
                simplified = get_class_properties(res)
                res = json_compatible(simplified)
            if isinstance(res, dict):
                res = json_compatible(res, camel_keys, skip_caps)
        except Exception as err:
            _log.error(err)
    finally:
        return res</code></pre>
</details>
</dd>
<dt id="fieldedge_utilities.class_properties.snake_to_camel"><code class="name flex">
<span>def <span class="ident">snake_to_camel</span></span>(<span>snake_str: str, skip_caps: bool = False) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a snake_case string to camelCase.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>snake_str</code></strong></dt>
<dd>The string to convert.</dd>
<dt><strong><code>skip_caps</code></strong></dt>
<dd>If <code>True</code> will return CAPITAL_CASE unchanged</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The input string in camelCase structure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def snake_to_camel(snake_str: str, skip_caps: bool = False) -&gt; str:
    &#34;&#34;&#34;Converts a snake_case string to camelCase.
    
    Args:
        snake_str: The string to convert.
        skip_caps: If `True` will return CAPITAL_CASE unchanged
    
    Returns:
        The input string in camelCase structure.
        
    &#34;&#34;&#34;
    if not isinstance(snake_str, str) or not snake_str:
        raise ValueError(&#39;Invalid string input&#39;)
    if snake_str.isupper() and skip_caps:
        return snake_str
    words = snake_str.split(&#39;_&#39;)
    if len(words) == 1 and words[0] == snake_str:
        return snake_str
    return words[0].lower() + &#39;&#39;.join(w.title() for w in words[1:])</code></pre>
</details>
</dd>
<dt id="fieldedge_utilities.class_properties.tag_class_properties"><code class="name flex">
<span>def <span class="ident">tag_class_properties</span></span>(<span>instance: object, tag: str = None, json: bool = True, categorize: bool = False, include_values: bool = False, ignore: list[str] = []) ‑> list | dict</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the class public properties tagged with a routing prefix.</p>
<p>If a <code>tag</code> is not provided, the lowercase name of the instance's class will
be used.</p>
<p>Using the defaults will return a simple list of tagged property names
with the form <code>['tagProp1Name', 'tagProp2Name']</code></p>
<p>If <code>categorize</code> is <code>True</code> a dictionary is returned of the form
<code>{ 'read_only': ['tagProp1Name'], 'read_write': ['tagProp2Name']}</code> where
<code>read_only</code> or <code>read_write</code> are not present if no properties meet the
respective criteria. If <code>include_values</code> is also <code>True</code> each list will be
replaced by a nested dictionary
<code>{ 'tagProp1Name': &lt;prop1_value&gt;, 'tagProp2Name': &lt;prop2_value&gt; }</code></p>
<p>If <code>categorize</code> is <code>False</code> and <code>include_values</code> is <code>True</code> then a simple
dictionary of tagged names and values will be returned with the form
<code>{ 'tagProp1Name': &lt;prop1_value&gt;, 'tagProp2Name': &lt;prop2_value&gt; }</code></p>
<p>If <code>json</code> is <code>False</code> the above applies but property names will use
their original case e.g. <code>tag_prop1_name</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>instance</code></strong></dt>
<dd>A class instance to tag.</dd>
<dt><strong><code>tag</code></strong></dt>
<dd>The name of the routing prefix. If <code>None</code>, the calling function's
module <code>__name__</code> will be used.</dd>
<dt><strong><code>json</code></strong></dt>
<dd>A flag indicating whether to use camelCase keys.</dd>
<dt><strong><code>categorize</code></strong></dt>
<dd>A flag indicating whether to group as <code>read_only</code> and
<code>read_write</code>.</dd>
<dt><strong><code>include_values</code></strong></dt>
<dd>A flag indicating whether to return values or just
a list of property names.</dd>
<dt><strong><code>ignore</code></strong></dt>
<dd>A list of property names to ignore.</dd>
</dl>
<h2 id="retuns">Retuns</h2>
<p>A dictionary or list of strings (see docstring).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tag_class_properties(instance: object,
                         tag: str = None,
                         json: bool = True,
                         categorize: bool = False,
                         include_values: bool = False,
                         ignore: &#39;list[str]&#39; = [],
                         ) -&gt; &#39;list|dict&#39;:
    &#34;&#34;&#34;Retrieves the class public properties tagged with a routing prefix.
    
    If a `tag` is not provided, the lowercase name of the instance&#39;s class will
    be used.
    
    Using the defaults will return a simple list of tagged property names
    with the form `[&#39;tagProp1Name&#39;, &#39;tagProp2Name&#39;]`
    
    If `categorize` is `True` a dictionary is returned of the form
    `{ &#39;read_only&#39;: [&#39;tagProp1Name&#39;], &#39;read_write&#39;: [&#39;tagProp2Name&#39;]}` where
    `read_only` or `read_write` are not present if no properties meet the
    respective criteria. If `include_values` is also `True` each list will be
    replaced by a nested dictionary
    `{ &#39;tagProp1Name&#39;: &lt;prop1_value&gt;, &#39;tagProp2Name&#39;: &lt;prop2_value&gt; }`
    
    If `categorize` is `False` and `include_values` is `True` then a simple
    dictionary of tagged names and values will be returned with the form
    `{ &#39;tagProp1Name&#39;: &lt;prop1_value&gt;, &#39;tagProp2Name&#39;: &lt;prop2_value&gt; }`
    
    If `json` is `False` the above applies but property names will use
    their original case e.g. `tag_prop1_name`
    
    Args:
        instance: A class instance to tag.
        tag: The name of the routing prefix. If `None`, the calling function&#39;s
            module `__name__` will be used.
        json: A flag indicating whether to use camelCase keys.
        categorize: A flag indicating whether to group as `read_only` and
            `read_write`.
        include_values: A flag indicating whether to return values or just
            a list of property names.
        ignore: A list of property names to ignore.
    
    Retuns:
        A dictionary or list of strings (see docstring).
        
    &#34;&#34;&#34;
    if not isinstance(tag, str) or not tag:
        tag = get_tag_class(instance)
    class_props = get_class_properties(instance, ignore, categorize)
    if not categorize:
        if not include_values:
            return [tag_property(tag, prop, json) for prop in class_props]
        result = {}
        for prop, val in class_props.items():
            result[tag_property(tag, prop, json)] = val
        return result
    result = {}
    for category, props in class_props.items():
        assert isinstance(props, dict)
        if not include_values:
            result[category] = [tag_property(tag, prop, json) for prop in props]
        else:
            result[category] = {}
            for prop, val in props.items():
                result[category][tag_property(tag, prop, json)] = val
    return result</code></pre>
</details>
</dd>
<dt id="fieldedge_utilities.class_properties.tag_merge"><code class="name flex">
<span>def <span class="ident">tag_merge</span></span>(<span>*args) ‑> list | dict</span>
</code></dt>
<dd>
<div class="desc"><p>Merge multiple tagged property lists/dictionaries.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*args</code></strong></dt>
<dd>A set of dictionaries or lists, must all be the same structure.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Merged structure of whatever was passed in.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tag_merge(*args) -&gt; &#39;list|dict&#39;:
    &#34;&#34;&#34;Merge multiple tagged property lists/dictionaries.
    
    Args:
        *args: A set of dictionaries or lists, must all be the same structure.
    
    Returns:
        Merged structure of whatever was passed in.

    &#34;&#34;&#34;
    container_type = args[0].__class__.__name__
    if container_type not in (&#39;list&#39;, &#39;dict&#39;):
        raise ValueError(&#39;tag merge must be of list or dict type&#39;)
    if not all(arg.__class__.__name__ == container_type for arg in args):
        raise ValueError(&#39;args must all be of same type&#39;)
    if container_type == &#39;list&#39;:
        return list(itertools.chain(*args))
    merged = {}
    categories = [&#39;read_only&#39;, &#39;read_write&#39;]
    dict_0: dict = args[0]
    if any(k in categories for k in dict_0):
        for arg in args:
            assert isinstance(arg, dict)
            if not any(k in categories for k in arg):
                raise ValueError(&#39;Not all dictionaries are categorized&#39;)
            merged = _nested_tag_merge(arg, merged)
    else:
        for arg in args:
            assert isinstance(arg, dict)
            for k, v in arg.items():
                merged[k] = v      
    return merged</code></pre>
</details>
</dd>
<dt id="fieldedge_utilities.class_properties.tag_property"><code class="name flex">
<span>def <span class="ident">tag_property</span></span>(<span>tag: str, prop: str, json: bool = True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tag_property(tag: str, prop: str, json: bool = True):
    if json:
        return snake_to_camel(f&#39;{tag}_{prop}&#39;)
    return f&#39;{tag}_{prop}&#39;</code></pre>
</details>
</dd>
<dt id="fieldedge_utilities.class_properties.untag_class_property"><code class="name flex">
<span>def <span class="ident">untag_class_property</span></span>(<span>tagged_property: str, tag_or_instance: str|object = None, include_tag: bool = False) ‑> str | tuple[str, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Reverts a JSON-format tagged property to its PEP representation.</p>
<p>Expects a JSON-format tagged value e.g. <code>modemUniqueId</code> would return
<code>(unique_id, modem)</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tagged_property</code></strong></dt>
<dd>The tagged property value, allowing for camelCase.</dd>
<dt><strong><code>tag</code></strong></dt>
<dd>Optional to specify the tag, allowing for camelCase tags.</dd>
<dt><strong><code>include_tag</code></strong></dt>
<dd>If True, a tuple is returned with the tag as the second
element.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A string with the original property name, or a tuple with the original
property value in snake_case, and the tag</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def untag_class_property(tagged_property: str,
                         tag_or_instance: &#39;str|object&#39; = None,
                         include_tag: bool = False,
                         ) -&gt; &#39;str|tuple[str, str]&#39;:
    &#34;&#34;&#34;Reverts a JSON-format tagged property to its PEP representation.
    
    Expects a JSON-format tagged value e.g. `modemUniqueId` would return
    `(unique_id, modem)`.

    Args:
        tagged_property: The tagged property value, allowing for camelCase.
        tag: Optional to specify the tag, allowing for camelCase tags.
        include_tag: If True, a tuple is returned with the tag as the second
            element.
    
    Returns:
        A string with the original property name, or a tuple with the original
            property value in snake_case, and the tag

    &#34;&#34;&#34;
    if not isinstance(tag_or_instance, str):
        if not isinstance(tag_or_instance, object):
            raise ValueError(&#39;Missing tag or class instance to derive tag&#39;)
        tag = get_tag_class(tag_or_instance)
    else:
        tag = tag_or_instance
    if not tagged_property.startswith(tag):
        raise ValueError(f&#39;{tagged_property} does not start with {tag}&#39;)
    prop = camel_to_snake(tagged_property.replace(tag_or_instance, &#39;&#39;, 1))
    if not include_tag:
        return prop
    return (prop, tag)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fieldedge_utilities" href="index.html">fieldedge_utilities</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fieldedge_utilities.class_properties.cache_valid" href="#fieldedge_utilities.class_properties.cache_valid">cache_valid</a></code></li>
<li><code><a title="fieldedge_utilities.class_properties.camel_to_snake" href="#fieldedge_utilities.class_properties.camel_to_snake">camel_to_snake</a></code></li>
<li><code><a title="fieldedge_utilities.class_properties.equivalent_attributes" href="#fieldedge_utilities.class_properties.equivalent_attributes">equivalent_attributes</a></code></li>
<li><code><a title="fieldedge_utilities.class_properties.get_class_properties" href="#fieldedge_utilities.class_properties.get_class_properties">get_class_properties</a></code></li>
<li><code><a title="fieldedge_utilities.class_properties.get_tag_class" href="#fieldedge_utilities.class_properties.get_tag_class">get_tag_class</a></code></li>
<li><code><a title="fieldedge_utilities.class_properties.json_compatible" href="#fieldedge_utilities.class_properties.json_compatible">json_compatible</a></code></li>
<li><code><a title="fieldedge_utilities.class_properties.snake_to_camel" href="#fieldedge_utilities.class_properties.snake_to_camel">snake_to_camel</a></code></li>
<li><code><a title="fieldedge_utilities.class_properties.tag_class_properties" href="#fieldedge_utilities.class_properties.tag_class_properties">tag_class_properties</a></code></li>
<li><code><a title="fieldedge_utilities.class_properties.tag_merge" href="#fieldedge_utilities.class_properties.tag_merge">tag_merge</a></code></li>
<li><code><a title="fieldedge_utilities.class_properties.tag_property" href="#fieldedge_utilities.class_properties.tag_property">tag_property</a></code></li>
<li><code><a title="fieldedge_utilities.class_properties.untag_class_property" href="#fieldedge_utilities.class_properties.untag_class_property">untag_class_property</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>