<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>fieldedge_utilities.class_properties API documentation</title>
<meta name="description" content="FieldEdge class/property helpers" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fieldedge_utilities.class_properties</code></h1>
</header>
<section id="section-intro">
<p>FieldEdge class/property helpers</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;FieldEdge class/property helpers
&#34;&#34;&#34;

import json
import logging
import os
import re
import inspect
import itertools
from time import time
# from abc import ABC

from .logger import verbose_logging
# from .path import get_caller_name

PROPERTY_CACHE_DEFAULT = int(os.getenv(&#39;PROPERTY_CACHE_DEFAULT&#39;, 5))
READ_ONLY = &#39;info&#39;
READ_WRITE = &#39;config&#39;

_log = logging.getLogger(__name__)


def snake_to_camel(snake_str: str, skip_caps: bool = False) -&gt; str:
    &#34;&#34;&#34;Converts a snake_case string to camelCase.
    
    Args:
        snake_str: The string to convert.
        skip_caps: If `True` will return CAPITAL_CASE unchanged
    
    Returns:
        The input string in camelCase structure.
        
    &#34;&#34;&#34;
    if not isinstance(snake_str, str) or not snake_str:
        raise ValueError(&#39;Invalid string input&#39;)
    if snake_str.isupper() and skip_caps:
        return snake_str
    words = snake_str.split(&#39;_&#39;)
    if len(words) == 1 and words[0] == snake_str:
        return snake_str
    return words[0].lower() + &#39;&#39;.join(w.title() for w in words[1:])


def camel_to_snake(camel_str: str, skip_caps: bool = False) -&gt; str:
    &#34;&#34;&#34;Converts a camelCase string to snake_case.
    
    Args:
        camel_str: The string to convert.
        skip_caps: A flag if `True` will return CAPITAL_CASE unchanged.
        
    Returns:
        The input string in snake_case format.
        
    Raises:
        `ValueError` if camel_str is not a valid string.
        
    &#34;&#34;&#34;
    if not isinstance(camel_str, str) or not camel_str:
        raise ValueError(&#39;Invalid string input&#39;)
    if camel_str.isupper() and skip_caps:
        return camel_str
    snake_str = re.compile(r&#39;(?&lt;!^)(?=[A-Z])&#39;).sub(&#39;_&#39;, camel_str).lower()
    if &#39;__&#39; in snake_str:
        words = snake_str.split(&#39;__&#39;)
        snake_str = &#39;_&#39;.join(f&#39;{word.replace(&#34;_&#34;, &#34;&#34;)}&#39; for word in words)
    return snake_str


def cache_valid(ref_time: &#39;int|float&#39;,
                max_age: int = PROPERTY_CACHE_DEFAULT,
                tag: str = None,
                ) -&gt; bool:
    &#34;&#34;&#34;Determines if cached property value is younger than the threshold.
    
    `PROPERTY_CACHE_DEFAULT` = 5 seconds. Can be overridden as an environment
    variable.
    Many FieldEdge Class properties are derived from *slow* operations but may
    be queried in rapid succession and can be inter-dependent. Caching reduces
    query time for such values.
    
    Args:
        ref: The reference time (seconds) of the previously cached value
            (typically a private property held in a dictionary)
        max_age: The maximum age of the cached value in seconds.
        tag: The name of the property (used for debug purposes).
    
    Returns:
        False is the cache is stale and a new value should be queried from the
            raw resource.

    &#34;&#34;&#34;
    if ref_time is None:
        return False
    if not isinstance(ref_time, int):
        try:
            ref_time = int(ref_time)
        except:
            raise ValueError(&#39;Invalid reference time&#39;)
    cache_age = int(time()) - ref_time
    if cache_age &gt; max_age:
        if _vlog():
            tag = tag or &#39;?&#39;
            _log.debug(f&#39;Cached {tag} only {cache_age} seconds old&#39;
                       f&#39; (cache = {max_age}s)&#39;)
        return False
    if tag:
        _log.debug(f&#39;Using cached {tag} ({cache_age} seconds)&#39;)
    return True


def hasattr_static(obj: object, attr: str) -&gt; bool:
    &#34;&#34;&#34;Determines if an object has an attribute without calling the attribute.
    
    Args:
        obj: The object to inspect.
        attr: The name of the attribute to query.
    
    Returns:
        `True` if the object has the attribute.
        
    &#34;&#34;&#34;
    try:
        inspect.getattr_static(obj, attr)
        return True
    except AttributeError:
        return False


def property_is_read_only(instance: object, property_name: str) -&gt; bool:
    if not hasattr_static(instance, property_name):
        raise ValueError(f&#39;Object has no property {property_name}&#39;)
    prop = inspect.getattr_static(instance, property_name)
    try:
        return prop.fset is None
    except AttributeError:
        return False
        
    
def property_is_async(instance: object, property_name: str) -&gt; bool:
    if not hasattr_static(instance, property_name):
        raise ValueError(f&#39;Object has no property {property_name}&#39;)
    if inspect.isawaitable(getattr(instance, property_name)):
        return True
    return False

    
def get_class_tag(cls: type) -&gt; str:
    if isinstance(cls, type):
        return cls.__name__.lower()
    return cls.__class__.__name__.lower()


def get_class_properties(cls: type,
                         ignore: &#39;list[str]&#39; = [],
                         ) -&gt; &#39;list[str]|dict[str, list]&#39;:
    &#34;&#34;&#34;Returns non-hidden, non-callable properties/values of a Class instance.
    
    Also ignores CAPITAL_CASE attributes which are assumed to be constants.
    
    Args:
        cls: The Class whose properties will be derived
        ignore: A list of names to ignore (optional)
    
    Returns:
        A list of exposed property names.
        
    Raises:
        ValueError if `cls` does not have a `dir()` method or is not a `type`.
        
    &#34;&#34;&#34;
    if not dir(cls):
        raise ValueError(&#39;Invalid cls_instance - must have dir() method&#39;)
    if isinstance(cls, type) and &#39;__slots__&#39; not in dir(cls):
        _log.warning(f&#39;No __slots__: attributes in __init__ will be missed&#39;)
    attrs = [attr for attr in dir(cls)
             if not attr.startswith((&#39;_&#39;,)) and
             attr not in ignore and
             not callable(inspect.getattr_static(cls, attr)) and
             not attr.isupper()]
    return attrs


def get_instance_properties_values(instance: object) -&gt; dict:
    &#34;&#34;&#34;Returns the instance properties and values.&#34;&#34;&#34;
    props_list = get_class_properties(instance)
    props_values = {}
    for prop in props_list:
        props_values[prop] = getattr(instance, prop)
    return props_values


def tag_class_properties(cls: type,
                         tag: str = None,
                         auto_tag: bool = True,
                         json: bool = True,
                         categorize: bool = False,
                         ignore: &#39;list[str]&#39; = [],
                         ) -&gt; &#39;list|dict&#39;:
    &#34;&#34;&#34;Retrieves the class public properties tagged with a routing prefix.
    
    If a `tag` is not provided and `auto_tag` is `True` then the lowercase name
    of the instance&#39;s class will be used e.g. MyClass.property becomes
    myclassProperty.
    
    Using the defaults will return a simple list of tagged property names
    with the form `[&#39;tagProp1Name&#39;, &#39;tagProp2Name&#39;]`
    
    If `tag` is `None` and `auto_tag` is `False` then no tag will be applied
    and the native property names will be returned as JSON if `json` is `True`.
    
    If `categorize` is `True` a dictionary is returned of the form
    `{ &#39;info&#39;: [&#39;tagProp1Name&#39;], &#39;config&#39;: [&#39;tagProp2Name&#39;]}` where
    the category is not present if no properties meet the respective criteria.
    
    If `json` is `False` the above applies but property names will use
    their original case e.g. `tag_prop1_name`
    
    Args:
        cls: A class to tag.
        tag: The name of the routing prefix. If `None`, the calling function&#39;s
            module `__name__` will be used.
        auto_tag: If `True` will use the class name in lowercase.
        json: A flag indicating whether to use camelCase keys.
        categorize: A flag indicating whether to group as `info` and `config`.
        ignore: A list of property names to ignore.
    
    Retuns:
        A dictionary or list of strings (see docstring).
        
    &#34;&#34;&#34;
    # TODO: class checking seems not to work for certain subclasses
    if isinstance(cls, type) and _vlog():
        _log.debug(&#39;Processing for class type&#39;)
    # elif issubclass(cls, ABC):
    #     _log.debug(&#39;Processing for microservice&#39;)
    if auto_tag and not tag:
        tag = get_class_tag(cls)
    class_props = get_class_properties(cls,
                                       ignore)
    if not categorize:
        return [tag_class_property(prop, tag, json) for prop in class_props]
    result = {}
    for prop in class_props:
        if property_is_read_only(cls, prop):
            if READ_ONLY not in result:
                result[READ_ONLY] = []
            result[READ_ONLY].append(tag_class_property(prop, tag, json))
        else:
            if READ_WRITE not in result:
                result[READ_WRITE] = []
            result[READ_WRITE].append(tag_class_property(prop, tag, json))
    return result


def tag_class_property(prop: str,
                       tag_or_cls: &#39;str|type&#39; = None,
                       json: bool = True) -&gt; str:
    &#34;&#34;&#34;Converts a property for ISC adding an optional tag.&#34;&#34;&#34;
    if tag_or_cls is None:
        tagged = prop
    else:
        if isinstance(tag_or_cls, type):
            tag = get_class_tag(tag_or_cls)
        elif isinstance(tag_or_cls, str):
            tag = tag_or_cls
        else:
            raise ValueError(&#39;tag_or_cls must be a string or class type&#39;)
        tagged = f&#39;{tag.lower()}_{prop}&#39;
    if json:
        return snake_to_camel(f&#39;{tagged}&#39;)
    return f&#39;{tag}_{prop}&#39;


def untag_class_property(property_name: str,
                         is_tagged: bool = True,
                         include_tag: bool = False,
                         ) -&gt; &#39;str|tuple[str, str]&#39;:
    &#34;&#34;&#34;Reverts a JSON-format tagged property to its PEP representation.
    
    Expects a JSON-format tagged value e.g. `modemUniqueId` would return
    `(unique_id, modem)` where it assumes the first word is the tag.

    Args:
        property_name: The property name, assumes using camelCase.
        include_tag: If True, a tuple is returned with the tag as the second
            element.
    
    Returns:
        A string with the original property name, or a tuple with the original
            property value in snake_case, and the tag

    &#34;&#34;&#34;
    if &#39;_&#39; not in camel_to_snake(property_name):
        raise ValueError(f&#39;Invalid camelCase {property_name}&#39;)
    if is_tagged:
        tag, prop = camel_to_snake(property_name).split(&#39;_&#39;, 1)
    else:
        tag, prop = None, camel_to_snake(property_name)
    if not include_tag:
        return prop
    return (prop, tag)


def tag_merge(*args) -&gt; &#39;list|dict&#39;:
    &#34;&#34;&#34;Merge multiple tagged property lists/dictionaries.
    
    Args:
        *args: A set of dictionaries or lists, must all be the same structure.
    
    Returns:
        Merged structure of whatever was passed in.

    &#34;&#34;&#34;
    container_type = args[0].__class__.__name__
    if container_type not in (&#39;list&#39;, &#39;dict&#39;):
        raise ValueError(&#39;tag merge must be of list or dict type&#39;)
    if not all(arg.__class__.__name__ == container_type for arg in args):
        raise ValueError(&#39;args must all be of same type&#39;)
    if container_type == &#39;list&#39;:
        return list(itertools.chain(*args))
    merged = {}
    categories = [READ_ONLY, READ_WRITE]
    dict_0: dict = args[0]
    if any(k in categories for k in dict_0):
        for arg in args:
            assert isinstance(arg, dict)
            if not any(k in categories for k in arg):
                raise ValueError(&#39;Not all dictionaries are categorized&#39;)
            merged = _nested_tag_merge(arg, merged)
    else:
        for arg in args:
            assert isinstance(arg, dict)
            for k, v in arg.items():
                merged[k] = v      
    return merged


def _nested_tag_merge(add: dict, merged: dict) -&gt; dict:
    for k, v in add.items():
        if k not in merged:
            merged[k] = v
        else:
            if isinstance(merged[k], list):
                merged[k] = merged[k] + v
            else:
                assert isinstance(merged[k], dict)
                assert isinstance(v, dict)
                for nk, nv in v.items():
                    merged[k][nk] = nv
    return merged


def json_compatible(obj: object,
                    camel_keys: bool = True,
                    skip_caps: bool = True) -&gt; dict:
    &#34;&#34;&#34;Returns a dictionary compatible with `json.dumps` function.

    Nested objects are converted to dictionaries.
    
    Args:
        obj: The source object.
        camel_keys: Flag indicating whether to convert all nested dictionary
            keys to `camelCase`.
        skip_caps: Preserves `CAPITAL_CASE` keys if True
        
    Returns:
        A dictionary with nested arrays, dictionaries and other compatible with
            `json.dumps`.

    &#34;&#34;&#34;
    res = obj
    if camel_keys:
        if isinstance(obj, dict):
            res = {}
            for k, v in obj.items():
                if ((isinstance(k, str) and k.isupper() and skip_caps) or
                    not isinstance(k, str)):
                    # no change
                    camel_key = k
                else:
                    camel_key = snake_to_camel(str(k))
                if camel_key != k and _vlog():
                    _log.debug(f&#39;Changed {k} to {camel_key}&#39;)
                res[camel_key] = json_compatible(v, camel_keys, skip_caps)
        elif isinstance(obj, list):
            res = []
            for item in obj:
                res.append(json_compatible(item, camel_keys, skip_caps))
    try:
        json.dumps(res)
    except TypeError:
        try:
            if isinstance(res, list):
                _temp = []
                for element in res:
                    _temp.append(json_compatible(element,
                                                 camel_keys,
                                                 skip_caps))
                res = _temp
            if hasattr(res, &#39;__dict__&#39;):
                res = json_compatible(get_instance_properties_values(res))
            if isinstance(res, dict):
                res = json_compatible(res, camel_keys, skip_caps)
        except Exception as err:
            _log.error(err)
    finally:
        return res


def equivalent_attributes(ref: object,
                          other: object,
                          exclude: &#39;list[str]&#39; = [],
                          dbg: str = &#39;&#39;,
                          ) -&gt; bool:
    &#34;&#34;&#34;Confirms attribute equivalence between objects of the same type.
    
    Args:
        ref: The reference object being compared to.
        other: The object comparing against the reference.
        exclude: Optional list of attribute names to exclude from comparison.
    
    Returns:
        True if all (non-excluded) attribute name/values match.

    &#34;&#34;&#34;
    if type(ref) != type(other):
        return False
    if not hasattr(ref, &#39;__dict__&#39;) or not hasattr(other, &#39;__dict__&#39;):
        return ref == other
    if dbg:
        dbg += &#39;.&#39;
    for attr in dir(ref):
        if attr.startswith(&#39;__&#39;) or attr in exclude:
            continue
        if not hasattr(other, attr):
            _log.debug(f&#39;Other missing {dbg}{attr}&#39;)
            return False
        ref_val = getattr(ref, attr)
        if callable(ref_val):
            continue
        other_val = getattr(other, attr)
        if any(hasattr(ref_val, a) for a in [&#39;__dict__&#39;, &#39;__slots__&#39;]):
            if not equivalent_attributes(ref_val, other_val, dbg=attr):
                return False
        elif ref_val != other_val:
            _log.debug(f&#39;{dbg}{attr} mismatch&#39;)
            return False
    return True


def _vlog() -&gt; bool:
    return verbose_logging(&#39;classes&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="fieldedge_utilities.class_properties.cache_valid"><code class="name flex">
<span>def <span class="ident">cache_valid</span></span>(<span>ref_time: int|float, max_age: int = 5, tag: str = None) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if cached property value is younger than the threshold.</p>
<p><code>PROPERTY_CACHE_DEFAULT</code> = 5 seconds. Can be overridden as an environment
variable.
Many FieldEdge Class properties are derived from <em>slow</em> operations but may
be queried in rapid succession and can be inter-dependent. Caching reduces
query time for such values.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ref</code></strong></dt>
<dd>The reference time (seconds) of the previously cached value
(typically a private property held in a dictionary)</dd>
<dt><strong><code>max_age</code></strong></dt>
<dd>The maximum age of the cached value in seconds.</dd>
<dt><strong><code>tag</code></strong></dt>
<dd>The name of the property (used for debug purposes).</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>False is the cache is stale and a new value should be queried from the
raw resource.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cache_valid(ref_time: &#39;int|float&#39;,
                max_age: int = PROPERTY_CACHE_DEFAULT,
                tag: str = None,
                ) -&gt; bool:
    &#34;&#34;&#34;Determines if cached property value is younger than the threshold.
    
    `PROPERTY_CACHE_DEFAULT` = 5 seconds. Can be overridden as an environment
    variable.
    Many FieldEdge Class properties are derived from *slow* operations but may
    be queried in rapid succession and can be inter-dependent. Caching reduces
    query time for such values.
    
    Args:
        ref: The reference time (seconds) of the previously cached value
            (typically a private property held in a dictionary)
        max_age: The maximum age of the cached value in seconds.
        tag: The name of the property (used for debug purposes).
    
    Returns:
        False is the cache is stale and a new value should be queried from the
            raw resource.

    &#34;&#34;&#34;
    if ref_time is None:
        return False
    if not isinstance(ref_time, int):
        try:
            ref_time = int(ref_time)
        except:
            raise ValueError(&#39;Invalid reference time&#39;)
    cache_age = int(time()) - ref_time
    if cache_age &gt; max_age:
        if _vlog():
            tag = tag or &#39;?&#39;
            _log.debug(f&#39;Cached {tag} only {cache_age} seconds old&#39;
                       f&#39; (cache = {max_age}s)&#39;)
        return False
    if tag:
        _log.debug(f&#39;Using cached {tag} ({cache_age} seconds)&#39;)
    return True</code></pre>
</details>
</dd>
<dt id="fieldedge_utilities.class_properties.camel_to_snake"><code class="name flex">
<span>def <span class="ident">camel_to_snake</span></span>(<span>camel_str: str, skip_caps: bool = False) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a camelCase string to snake_case.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>camel_str</code></strong></dt>
<dd>The string to convert.</dd>
<dt><strong><code>skip_caps</code></strong></dt>
<dd>A flag if <code>True</code> will return CAPITAL_CASE unchanged.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The input string in snake_case format.</p>
<h2 id="raises">Raises</h2>
<p><code>ValueError</code> if camel_str is not a valid string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def camel_to_snake(camel_str: str, skip_caps: bool = False) -&gt; str:
    &#34;&#34;&#34;Converts a camelCase string to snake_case.
    
    Args:
        camel_str: The string to convert.
        skip_caps: A flag if `True` will return CAPITAL_CASE unchanged.
        
    Returns:
        The input string in snake_case format.
        
    Raises:
        `ValueError` if camel_str is not a valid string.
        
    &#34;&#34;&#34;
    if not isinstance(camel_str, str) or not camel_str:
        raise ValueError(&#39;Invalid string input&#39;)
    if camel_str.isupper() and skip_caps:
        return camel_str
    snake_str = re.compile(r&#39;(?&lt;!^)(?=[A-Z])&#39;).sub(&#39;_&#39;, camel_str).lower()
    if &#39;__&#39; in snake_str:
        words = snake_str.split(&#39;__&#39;)
        snake_str = &#39;_&#39;.join(f&#39;{word.replace(&#34;_&#34;, &#34;&#34;)}&#39; for word in words)
    return snake_str</code></pre>
</details>
</dd>
<dt id="fieldedge_utilities.class_properties.equivalent_attributes"><code class="name flex">
<span>def <span class="ident">equivalent_attributes</span></span>(<span>ref: object, other: object, exclude: list[str] = [], dbg: str = '') ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Confirms attribute equivalence between objects of the same type.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>ref</code></strong></dt>
<dd>The reference object being compared to.</dd>
<dt><strong><code>other</code></strong></dt>
<dd>The object comparing against the reference.</dd>
<dt><strong><code>exclude</code></strong></dt>
<dd>Optional list of attribute names to exclude from comparison.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>True if all (non-excluded) attribute name/values match.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def equivalent_attributes(ref: object,
                          other: object,
                          exclude: &#39;list[str]&#39; = [],
                          dbg: str = &#39;&#39;,
                          ) -&gt; bool:
    &#34;&#34;&#34;Confirms attribute equivalence between objects of the same type.
    
    Args:
        ref: The reference object being compared to.
        other: The object comparing against the reference.
        exclude: Optional list of attribute names to exclude from comparison.
    
    Returns:
        True if all (non-excluded) attribute name/values match.

    &#34;&#34;&#34;
    if type(ref) != type(other):
        return False
    if not hasattr(ref, &#39;__dict__&#39;) or not hasattr(other, &#39;__dict__&#39;):
        return ref == other
    if dbg:
        dbg += &#39;.&#39;
    for attr in dir(ref):
        if attr.startswith(&#39;__&#39;) or attr in exclude:
            continue
        if not hasattr(other, attr):
            _log.debug(f&#39;Other missing {dbg}{attr}&#39;)
            return False
        ref_val = getattr(ref, attr)
        if callable(ref_val):
            continue
        other_val = getattr(other, attr)
        if any(hasattr(ref_val, a) for a in [&#39;__dict__&#39;, &#39;__slots__&#39;]):
            if not equivalent_attributes(ref_val, other_val, dbg=attr):
                return False
        elif ref_val != other_val:
            _log.debug(f&#39;{dbg}{attr} mismatch&#39;)
            return False
    return True</code></pre>
</details>
</dd>
<dt id="fieldedge_utilities.class_properties.get_class_properties"><code class="name flex">
<span>def <span class="ident">get_class_properties</span></span>(<span>cls: type, ignore: list[str] = []) ‑> list[str] | dict[str, list]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns non-hidden, non-callable properties/values of a Class instance.</p>
<p>Also ignores CAPITAL_CASE attributes which are assumed to be constants.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cls</code></strong></dt>
<dd>The Class whose properties will be derived</dd>
<dt><strong><code>ignore</code></strong></dt>
<dd>A list of names to ignore (optional)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A list of exposed property names.</p>
<h2 id="raises">Raises</h2>
<p>ValueError if <code>cls</code> does not have a <code>dir()</code> method or is not a <code>type</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_class_properties(cls: type,
                         ignore: &#39;list[str]&#39; = [],
                         ) -&gt; &#39;list[str]|dict[str, list]&#39;:
    &#34;&#34;&#34;Returns non-hidden, non-callable properties/values of a Class instance.
    
    Also ignores CAPITAL_CASE attributes which are assumed to be constants.
    
    Args:
        cls: The Class whose properties will be derived
        ignore: A list of names to ignore (optional)
    
    Returns:
        A list of exposed property names.
        
    Raises:
        ValueError if `cls` does not have a `dir()` method or is not a `type`.
        
    &#34;&#34;&#34;
    if not dir(cls):
        raise ValueError(&#39;Invalid cls_instance - must have dir() method&#39;)
    if isinstance(cls, type) and &#39;__slots__&#39; not in dir(cls):
        _log.warning(f&#39;No __slots__: attributes in __init__ will be missed&#39;)
    attrs = [attr for attr in dir(cls)
             if not attr.startswith((&#39;_&#39;,)) and
             attr not in ignore and
             not callable(inspect.getattr_static(cls, attr)) and
             not attr.isupper()]
    return attrs</code></pre>
</details>
</dd>
<dt id="fieldedge_utilities.class_properties.get_class_tag"><code class="name flex">
<span>def <span class="ident">get_class_tag</span></span>(<span>cls: type) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_class_tag(cls: type) -&gt; str:
    if isinstance(cls, type):
        return cls.__name__.lower()
    return cls.__class__.__name__.lower()</code></pre>
</details>
</dd>
<dt id="fieldedge_utilities.class_properties.get_instance_properties_values"><code class="name flex">
<span>def <span class="ident">get_instance_properties_values</span></span>(<span>instance: object) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the instance properties and values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_instance_properties_values(instance: object) -&gt; dict:
    &#34;&#34;&#34;Returns the instance properties and values.&#34;&#34;&#34;
    props_list = get_class_properties(instance)
    props_values = {}
    for prop in props_list:
        props_values[prop] = getattr(instance, prop)
    return props_values</code></pre>
</details>
</dd>
<dt id="fieldedge_utilities.class_properties.hasattr_static"><code class="name flex">
<span>def <span class="ident">hasattr_static</span></span>(<span>obj: object, attr: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Determines if an object has an attribute without calling the attribute.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong></dt>
<dd>The object to inspect.</dd>
<dt><strong><code>attr</code></strong></dt>
<dd>The name of the attribute to query.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>True</code> if the object has the attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hasattr_static(obj: object, attr: str) -&gt; bool:
    &#34;&#34;&#34;Determines if an object has an attribute without calling the attribute.
    
    Args:
        obj: The object to inspect.
        attr: The name of the attribute to query.
    
    Returns:
        `True` if the object has the attribute.
        
    &#34;&#34;&#34;
    try:
        inspect.getattr_static(obj, attr)
        return True
    except AttributeError:
        return False</code></pre>
</details>
</dd>
<dt id="fieldedge_utilities.class_properties.json_compatible"><code class="name flex">
<span>def <span class="ident">json_compatible</span></span>(<span>obj: object, camel_keys: bool = True, skip_caps: bool = True) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dictionary compatible with <code>json.dumps</code> function.</p>
<p>Nested objects are converted to dictionaries.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong></dt>
<dd>The source object.</dd>
<dt><strong><code>camel_keys</code></strong></dt>
<dd>Flag indicating whether to convert all nested dictionary
keys to <code>camelCase</code>.</dd>
<dt><strong><code>skip_caps</code></strong></dt>
<dd>Preserves <code>CAPITAL_CASE</code> keys if True</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary with nested arrays, dictionaries and other compatible with
<code>json.dumps</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def json_compatible(obj: object,
                    camel_keys: bool = True,
                    skip_caps: bool = True) -&gt; dict:
    &#34;&#34;&#34;Returns a dictionary compatible with `json.dumps` function.

    Nested objects are converted to dictionaries.
    
    Args:
        obj: The source object.
        camel_keys: Flag indicating whether to convert all nested dictionary
            keys to `camelCase`.
        skip_caps: Preserves `CAPITAL_CASE` keys if True
        
    Returns:
        A dictionary with nested arrays, dictionaries and other compatible with
            `json.dumps`.

    &#34;&#34;&#34;
    res = obj
    if camel_keys:
        if isinstance(obj, dict):
            res = {}
            for k, v in obj.items():
                if ((isinstance(k, str) and k.isupper() and skip_caps) or
                    not isinstance(k, str)):
                    # no change
                    camel_key = k
                else:
                    camel_key = snake_to_camel(str(k))
                if camel_key != k and _vlog():
                    _log.debug(f&#39;Changed {k} to {camel_key}&#39;)
                res[camel_key] = json_compatible(v, camel_keys, skip_caps)
        elif isinstance(obj, list):
            res = []
            for item in obj:
                res.append(json_compatible(item, camel_keys, skip_caps))
    try:
        json.dumps(res)
    except TypeError:
        try:
            if isinstance(res, list):
                _temp = []
                for element in res:
                    _temp.append(json_compatible(element,
                                                 camel_keys,
                                                 skip_caps))
                res = _temp
            if hasattr(res, &#39;__dict__&#39;):
                res = json_compatible(get_instance_properties_values(res))
            if isinstance(res, dict):
                res = json_compatible(res, camel_keys, skip_caps)
        except Exception as err:
            _log.error(err)
    finally:
        return res</code></pre>
</details>
</dd>
<dt id="fieldedge_utilities.class_properties.property_is_async"><code class="name flex">
<span>def <span class="ident">property_is_async</span></span>(<span>instance: object, property_name: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def property_is_async(instance: object, property_name: str) -&gt; bool:
    if not hasattr_static(instance, property_name):
        raise ValueError(f&#39;Object has no property {property_name}&#39;)
    if inspect.isawaitable(getattr(instance, property_name)):
        return True
    return False</code></pre>
</details>
</dd>
<dt id="fieldedge_utilities.class_properties.property_is_read_only"><code class="name flex">
<span>def <span class="ident">property_is_read_only</span></span>(<span>instance: object, property_name: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def property_is_read_only(instance: object, property_name: str) -&gt; bool:
    if not hasattr_static(instance, property_name):
        raise ValueError(f&#39;Object has no property {property_name}&#39;)
    prop = inspect.getattr_static(instance, property_name)
    try:
        return prop.fset is None
    except AttributeError:
        return False</code></pre>
</details>
</dd>
<dt id="fieldedge_utilities.class_properties.snake_to_camel"><code class="name flex">
<span>def <span class="ident">snake_to_camel</span></span>(<span>snake_str: str, skip_caps: bool = False) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a snake_case string to camelCase.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>snake_str</code></strong></dt>
<dd>The string to convert.</dd>
<dt><strong><code>skip_caps</code></strong></dt>
<dd>If <code>True</code> will return CAPITAL_CASE unchanged</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The input string in camelCase structure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def snake_to_camel(snake_str: str, skip_caps: bool = False) -&gt; str:
    &#34;&#34;&#34;Converts a snake_case string to camelCase.
    
    Args:
        snake_str: The string to convert.
        skip_caps: If `True` will return CAPITAL_CASE unchanged
    
    Returns:
        The input string in camelCase structure.
        
    &#34;&#34;&#34;
    if not isinstance(snake_str, str) or not snake_str:
        raise ValueError(&#39;Invalid string input&#39;)
    if snake_str.isupper() and skip_caps:
        return snake_str
    words = snake_str.split(&#39;_&#39;)
    if len(words) == 1 and words[0] == snake_str:
        return snake_str
    return words[0].lower() + &#39;&#39;.join(w.title() for w in words[1:])</code></pre>
</details>
</dd>
<dt id="fieldedge_utilities.class_properties.tag_class_properties"><code class="name flex">
<span>def <span class="ident">tag_class_properties</span></span>(<span>cls: type, tag: str = None, auto_tag: bool = True, json: bool = True, categorize: bool = False, ignore: list[str] = []) ‑> list | dict</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the class public properties tagged with a routing prefix.</p>
<p>If a <code>tag</code> is not provided and <code>auto_tag</code> is <code>True</code> then the lowercase name
of the instance's class will be used e.g. MyClass.property becomes
myclassProperty.</p>
<p>Using the defaults will return a simple list of tagged property names
with the form <code>['tagProp1Name', 'tagProp2Name']</code></p>
<p>If <code>tag</code> is <code>None</code> and <code>auto_tag</code> is <code>False</code> then no tag will be applied
and the native property names will be returned as JSON if <code>json</code> is <code>True</code>.</p>
<p>If <code>categorize</code> is <code>True</code> a dictionary is returned of the form
<code>{ 'info': ['tagProp1Name'], 'config': ['tagProp2Name']}</code> where
the category is not present if no properties meet the respective criteria.</p>
<p>If <code>json</code> is <code>False</code> the above applies but property names will use
their original case e.g. <code>tag_prop1_name</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cls</code></strong></dt>
<dd>A class to tag.</dd>
<dt><strong><code>tag</code></strong></dt>
<dd>The name of the routing prefix. If <code>None</code>, the calling function's
module <code>__name__</code> will be used.</dd>
<dt><strong><code>auto_tag</code></strong></dt>
<dd>If <code>True</code> will use the class name in lowercase.</dd>
<dt><strong><code>json</code></strong></dt>
<dd>A flag indicating whether to use camelCase keys.</dd>
<dt><strong><code>categorize</code></strong></dt>
<dd>A flag indicating whether to group as <code>info</code> and <code>config</code>.</dd>
<dt><strong><code>ignore</code></strong></dt>
<dd>A list of property names to ignore.</dd>
</dl>
<h2 id="retuns">Retuns</h2>
<p>A dictionary or list of strings (see docstring).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tag_class_properties(cls: type,
                         tag: str = None,
                         auto_tag: bool = True,
                         json: bool = True,
                         categorize: bool = False,
                         ignore: &#39;list[str]&#39; = [],
                         ) -&gt; &#39;list|dict&#39;:
    &#34;&#34;&#34;Retrieves the class public properties tagged with a routing prefix.
    
    If a `tag` is not provided and `auto_tag` is `True` then the lowercase name
    of the instance&#39;s class will be used e.g. MyClass.property becomes
    myclassProperty.
    
    Using the defaults will return a simple list of tagged property names
    with the form `[&#39;tagProp1Name&#39;, &#39;tagProp2Name&#39;]`
    
    If `tag` is `None` and `auto_tag` is `False` then no tag will be applied
    and the native property names will be returned as JSON if `json` is `True`.
    
    If `categorize` is `True` a dictionary is returned of the form
    `{ &#39;info&#39;: [&#39;tagProp1Name&#39;], &#39;config&#39;: [&#39;tagProp2Name&#39;]}` where
    the category is not present if no properties meet the respective criteria.
    
    If `json` is `False` the above applies but property names will use
    their original case e.g. `tag_prop1_name`
    
    Args:
        cls: A class to tag.
        tag: The name of the routing prefix. If `None`, the calling function&#39;s
            module `__name__` will be used.
        auto_tag: If `True` will use the class name in lowercase.
        json: A flag indicating whether to use camelCase keys.
        categorize: A flag indicating whether to group as `info` and `config`.
        ignore: A list of property names to ignore.
    
    Retuns:
        A dictionary or list of strings (see docstring).
        
    &#34;&#34;&#34;
    # TODO: class checking seems not to work for certain subclasses
    if isinstance(cls, type) and _vlog():
        _log.debug(&#39;Processing for class type&#39;)
    # elif issubclass(cls, ABC):
    #     _log.debug(&#39;Processing for microservice&#39;)
    if auto_tag and not tag:
        tag = get_class_tag(cls)
    class_props = get_class_properties(cls,
                                       ignore)
    if not categorize:
        return [tag_class_property(prop, tag, json) for prop in class_props]
    result = {}
    for prop in class_props:
        if property_is_read_only(cls, prop):
            if READ_ONLY not in result:
                result[READ_ONLY] = []
            result[READ_ONLY].append(tag_class_property(prop, tag, json))
        else:
            if READ_WRITE not in result:
                result[READ_WRITE] = []
            result[READ_WRITE].append(tag_class_property(prop, tag, json))
    return result</code></pre>
</details>
</dd>
<dt id="fieldedge_utilities.class_properties.tag_class_property"><code class="name flex">
<span>def <span class="ident">tag_class_property</span></span>(<span>prop: str, tag_or_cls: str|type = None, json: bool = True) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a property for ISC adding an optional tag.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tag_class_property(prop: str,
                       tag_or_cls: &#39;str|type&#39; = None,
                       json: bool = True) -&gt; str:
    &#34;&#34;&#34;Converts a property for ISC adding an optional tag.&#34;&#34;&#34;
    if tag_or_cls is None:
        tagged = prop
    else:
        if isinstance(tag_or_cls, type):
            tag = get_class_tag(tag_or_cls)
        elif isinstance(tag_or_cls, str):
            tag = tag_or_cls
        else:
            raise ValueError(&#39;tag_or_cls must be a string or class type&#39;)
        tagged = f&#39;{tag.lower()}_{prop}&#39;
    if json:
        return snake_to_camel(f&#39;{tagged}&#39;)
    return f&#39;{tag}_{prop}&#39;</code></pre>
</details>
</dd>
<dt id="fieldedge_utilities.class_properties.tag_merge"><code class="name flex">
<span>def <span class="ident">tag_merge</span></span>(<span>*args) ‑> list | dict</span>
</code></dt>
<dd>
<div class="desc"><p>Merge multiple tagged property lists/dictionaries.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*args</code></strong></dt>
<dd>A set of dictionaries or lists, must all be the same structure.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Merged structure of whatever was passed in.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tag_merge(*args) -&gt; &#39;list|dict&#39;:
    &#34;&#34;&#34;Merge multiple tagged property lists/dictionaries.
    
    Args:
        *args: A set of dictionaries or lists, must all be the same structure.
    
    Returns:
        Merged structure of whatever was passed in.

    &#34;&#34;&#34;
    container_type = args[0].__class__.__name__
    if container_type not in (&#39;list&#39;, &#39;dict&#39;):
        raise ValueError(&#39;tag merge must be of list or dict type&#39;)
    if not all(arg.__class__.__name__ == container_type for arg in args):
        raise ValueError(&#39;args must all be of same type&#39;)
    if container_type == &#39;list&#39;:
        return list(itertools.chain(*args))
    merged = {}
    categories = [READ_ONLY, READ_WRITE]
    dict_0: dict = args[0]
    if any(k in categories for k in dict_0):
        for arg in args:
            assert isinstance(arg, dict)
            if not any(k in categories for k in arg):
                raise ValueError(&#39;Not all dictionaries are categorized&#39;)
            merged = _nested_tag_merge(arg, merged)
    else:
        for arg in args:
            assert isinstance(arg, dict)
            for k, v in arg.items():
                merged[k] = v      
    return merged</code></pre>
</details>
</dd>
<dt id="fieldedge_utilities.class_properties.untag_class_property"><code class="name flex">
<span>def <span class="ident">untag_class_property</span></span>(<span>property_name: str, is_tagged: bool = True, include_tag: bool = False) ‑> str | tuple[str, str]</span>
</code></dt>
<dd>
<div class="desc"><p>Reverts a JSON-format tagged property to its PEP representation.</p>
<p>Expects a JSON-format tagged value e.g. <code>modemUniqueId</code> would return
<code>(unique_id, modem)</code> where it assumes the first word is the tag.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>property_name</code></strong></dt>
<dd>The property name, assumes using camelCase.</dd>
<dt><strong><code>include_tag</code></strong></dt>
<dd>If True, a tuple is returned with the tag as the second
element.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A string with the original property name, or a tuple with the original
property value in snake_case, and the tag</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def untag_class_property(property_name: str,
                         is_tagged: bool = True,
                         include_tag: bool = False,
                         ) -&gt; &#39;str|tuple[str, str]&#39;:
    &#34;&#34;&#34;Reverts a JSON-format tagged property to its PEP representation.
    
    Expects a JSON-format tagged value e.g. `modemUniqueId` would return
    `(unique_id, modem)` where it assumes the first word is the tag.

    Args:
        property_name: The property name, assumes using camelCase.
        include_tag: If True, a tuple is returned with the tag as the second
            element.
    
    Returns:
        A string with the original property name, or a tuple with the original
            property value in snake_case, and the tag

    &#34;&#34;&#34;
    if &#39;_&#39; not in camel_to_snake(property_name):
        raise ValueError(f&#39;Invalid camelCase {property_name}&#39;)
    if is_tagged:
        tag, prop = camel_to_snake(property_name).split(&#39;_&#39;, 1)
    else:
        tag, prop = None, camel_to_snake(property_name)
    if not include_tag:
        return prop
    return (prop, tag)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fieldedge_utilities" href="index.html">fieldedge_utilities</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="fieldedge_utilities.class_properties.cache_valid" href="#fieldedge_utilities.class_properties.cache_valid">cache_valid</a></code></li>
<li><code><a title="fieldedge_utilities.class_properties.camel_to_snake" href="#fieldedge_utilities.class_properties.camel_to_snake">camel_to_snake</a></code></li>
<li><code><a title="fieldedge_utilities.class_properties.equivalent_attributes" href="#fieldedge_utilities.class_properties.equivalent_attributes">equivalent_attributes</a></code></li>
<li><code><a title="fieldedge_utilities.class_properties.get_class_properties" href="#fieldedge_utilities.class_properties.get_class_properties">get_class_properties</a></code></li>
<li><code><a title="fieldedge_utilities.class_properties.get_class_tag" href="#fieldedge_utilities.class_properties.get_class_tag">get_class_tag</a></code></li>
<li><code><a title="fieldedge_utilities.class_properties.get_instance_properties_values" href="#fieldedge_utilities.class_properties.get_instance_properties_values">get_instance_properties_values</a></code></li>
<li><code><a title="fieldedge_utilities.class_properties.hasattr_static" href="#fieldedge_utilities.class_properties.hasattr_static">hasattr_static</a></code></li>
<li><code><a title="fieldedge_utilities.class_properties.json_compatible" href="#fieldedge_utilities.class_properties.json_compatible">json_compatible</a></code></li>
<li><code><a title="fieldedge_utilities.class_properties.property_is_async" href="#fieldedge_utilities.class_properties.property_is_async">property_is_async</a></code></li>
<li><code><a title="fieldedge_utilities.class_properties.property_is_read_only" href="#fieldedge_utilities.class_properties.property_is_read_only">property_is_read_only</a></code></li>
<li><code><a title="fieldedge_utilities.class_properties.snake_to_camel" href="#fieldedge_utilities.class_properties.snake_to_camel">snake_to_camel</a></code></li>
<li><code><a title="fieldedge_utilities.class_properties.tag_class_properties" href="#fieldedge_utilities.class_properties.tag_class_properties">tag_class_properties</a></code></li>
<li><code><a title="fieldedge_utilities.class_properties.tag_class_property" href="#fieldedge_utilities.class_properties.tag_class_property">tag_class_property</a></code></li>
<li><code><a title="fieldedge_utilities.class_properties.tag_merge" href="#fieldedge_utilities.class_properties.tag_merge">tag_merge</a></code></li>
<li><code><a title="fieldedge_utilities.class_properties.untag_class_property" href="#fieldedge_utilities.class_properties.untag_class_property">untag_class_property</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>